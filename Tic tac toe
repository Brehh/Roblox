

local function colorsAreSimilar(color1: Color3, color2: Color3, threshold: number): boolean
    local diffR = color1.R - color2.R
    local diffG = color1.G - color2.G
    local diffB = color1.B - color2.B

    local distanceSquared = diffR^2 + diffG^2 + diffB^2
    local distance = math.sqrt(distanceSquared)

    return distance < threshold
end



local vim = game:GetService('VirtualInputManager')
local gameSettings = UserSettings().GameSettings
local inFullscreen = gameSettings:InFullScreen()

function getpos(SurfaceGui)
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Player = Players.LocalPlayer
    local Camera = workspace.CurrentCamera

    local GuiObject = SurfaceGui:FindFirstChildOfClass("ImageButton") 
    if not GuiObject then GuiObject = SurfaceGui:FindFirstChildOfClass("Button") end

    if not GuiObject or not SurfaceGui.Adornee or not Camera then
        warn("Could not find the necessary GUI element, Adornee part, or Camera.")
        return
    end

    local Part = SurfaceGui.Adornee

    -- 2. Function to convert a point on the SurfaceGui to a 3D World Position
    local function GetGuiWorldPoint(guiElement)
        local elementPosition = guiElement.AbsolutePosition 
        local elementSize = guiElement.AbsoluteSize
        local pixelsPerStud = SurfaceGui.PixelsPerStud

        -- Find the center of the GUI element in pixels (relative to SurfaceGui's top-left)
        local centerPixel = elementPosition + (elementSize / 2)

        -- Convert the pixel position to studs
        local centerStudsX = centerPixel.X / pixelsPerStud
        local centerStudsY = centerPixel.Y / pixelsPerStud
        
        -- SurfaceGui's size in studs based on the Adornee part's size on the Face
        local partSizeX, partSizeY, partSizeZ = Part.Size.X, Part.Size.Y, Part.Size.Z
        local surfaceFace = SurfaceGui.Face
        
        -- Determine the 'up' (Y) and 'right' (X) axes on the part relative to the SurfaceGui's Face
        -- This is highly dependent on the Face. For simplification, we'll use a common Face like 'Front'.

        -- Calculate the STUD offset from the center of the part
        -- X: From left (-0.5) to right (+0.5) of the part's face size
        local offsetFromCenterStudsX = centerStudsX / (Part.Size.X * pixelsPerStud) - 0.5
        -- Y: From top (+0.5) to bottom (-0.5) of the part's face size (Y is inverted on the GUI)
        local offsetFromCenterStudsY = 0.5 - centerStudsY / (Part.Size.Y * pixelsPerStud)
        
        -- CFrame math for a 'Front' face (SurfaceGui X is Part X, SurfaceGui Y is Part Y)
        local offsetCFrame = CFrame.new(
            offsetFromCenterStudsX * partSizeX, -- Local X offset
            offsetFromCenterStudsY * partSizeY, -- Local Y offset
            -partSizeZ / 2 - 0.001 -- Small offset into the part's face for rendering. Use the Z value of the part to position it on the surface.
        )

        -- Transform the local offset into a world position
        return Part.CFrame * offsetCFrame.Position
    end

    -- 3. Loop to constantly update and check the screen position
        local worldPoint = GetGuiWorldPoint(GuiObject)

        -- Convert the 3D world position to a 2D screen position
        local screenPointVector3, isOnScreen = Camera:WorldToScreenPoint(worldPoint)

        if isOnScreen then
            local absoluteScreenPosition = Vector2.new(screenPointVector3.X, screenPointVector3.Y)
            -- Print the absolute position in pixels on the screen (Top-Left is 0,0)
            return absoluteScreenPosition
        else
            return nil
        end
end

function pressbutton(obj)
    local xddd = obj.AbsolutePosition + obj.AbsoluteSize / 2
    if not inFullscreen then
        vim:SendMouseButtonEvent(xddd.X,xddd.Y+50, 0, true, game, 1)
        vim:SendMouseButtonEvent(xddd.X,xddd.Y+50, 0, false, game, 1)
    else
        vim:SendMouseButtonEvent(xddd.X,xddd.Y, 0, true, game, 1)
        vim:SendMouseButtonEvent(xddd.X,xddd.Y, 0, false, game, 1)
    end
end

function presspos(xddd)
    if not inFullscreen then
        vim:SendMouseButtonEvent(xddd.X,xddd.Y+50, 0, true, game, 1)
        wait(0.1)
        vim:SendMouseButtonEvent(xddd.X,xddd.Y+50, 0, false, game, 1)
    else
        vim:SendMouseButtonEvent(xddd.X,xddd.Y, 0, true, game, 1)
        wait(0.1)
        vim:SendMouseButtonEvent(xddd.X,xddd.Y, 0, false, game, 1)
    end
end


print('-------------------------------------')

function ismoveleft(ox)
    for _,row in next, ox do
        for _,c in next, row do
            if c == 0 then
                return true
            end
        end
    end
    return false
end

function showboard(ox)
    print("+---+---+---+")
    for _,row in next, ox do
        local ohwow = " OX"
        local ohwow2 = {}

        for _,c in next, row do
            ohwow2[#ohwow2+1] = string.sub(ohwow, c+1, c+1)
        end
        print("| " .. table.concat(ohwow2," | ") .. " |")
        print("+---+---+---+")
    end
end

function getboard(me)
    local board = {}
    for i,v in next,me:GetChildren() do
        if #v.Name == 3 then
            local match = tonumber(string.match(v.Name,"%d+"))
            local row = math.floor(match/10)   -- ใช้ math.floor เพื่อความชัวร์
            local col = match % 10
            local check = (v.O.Visible == true) and 'O' or (v.X.Visible == true) and 'X' or ''
            if not board[row] then
                board[row] = {}
            end
            if check == 'X' then
                board[row][col] = 2
            elseif check == 'O' then
                board[row][col] = 1
            else
                board[row][col] = 0
            end
        end
    end
    return board
end

function checkifallequal(bruh)
    local first = bruh[1]
    for i= 2,#bruh do
        if bruh[i] ~= first or bruh[i] == 0 then
            return false
        end
    end
    return first
end

function checkwin(board)
    local ROW,COL = #board,#board[1]
    local howmany = 3
    howmany = howmany - 1
    -- horizontal
    for row = 1,ROW do
        for col = 1,COL-(howmany) do
            local window = {}
            for i = 0,2 do
                window[i+1] = board[row][col+i]
            end
            local whowin = checkifallequal(window)
            if whowin then
                return whowin
            end
        end
    end
    -- vertical
    for col = 1,COL do
        for row = 1,ROW-(howmany) do
            local window = {}
            for i = 0,2 do
                window[i+1] = board[row+i][col]
            end
            local whowin = checkifallequal(window)
            if whowin then
                return whowin
            end
        end
    end
    -- diagonal (top-right -> bottom-left)
    for row = howmany+1,ROW do
        for col = 1,COL-howmany do
            local window = {}
            for i = 0,2 do
                if board[row-i] and board[row-i][col+i] then
                    window[i+1] = board[row-i][col+i]
                end
            end
            local whowin = checkifallequal(window)
            if #window == howmany+1 and whowin then
                return whowin
            end
        end
    end
    -- diagonal (top-left -> bottom-right)
    for row = 1,ROW-howmany do
        for col = 1,COL-howmany do
            local window = {}
            for i = 0,2 do
                if board[row+i] and board[row+i][col+i] then
                    window[i+1] = board[row+i][col+i]
                end
            end
            local whowin = checkifallequal(window)
            if #window == howmany+1 and whowin then
                return whowin
            end
        end
    end
    return 0
end

function play(ox,r,c,turn)
    if ox[r][c] == 0 then
        ox[r][c] = turn
    end 
end

function unplay(ox,r,c,turn)
    if ox[r][c] == turn then
        ox[r][c] = 0
    end 
end

function allposmove(ox)
    local n = #ox
    local empty = {}
    for r = 1,n do
        for c = 1,n do
            if ox[r][c] == 0 then
                empty[#empty+1] = {r,c}
            end
        end
    end
    return empty
end

function eval(ox,depth)
    local win = checkwin(ox)
    if win == 1 then
        return (#ox * #ox[1] + 1) - depth
    elseif win == 2 then
        return depth - (#ox * #ox[1] + 1)
    end
    return 0
end

-- minimax: ismax == true  => player's turn is O (maximizer)
--           ismax == false => player's turn is X (minimizer)
function minimax(ox,depth,ismax,a,b,ailevelb)
    local score = eval(ox,depth)
    if score ~= 0 or (not ismoveleft(ox)) or depth == ailevelb then
        return score
    end

    if ismax then
        local best = -math.huge 
        for _,inside in ipairs(allposmove(ox)) do
            local r,c = inside[1], inside[2]
            play(ox,r,c,1)
            local evals = minimax(ox, depth+1, false, a, b, ailevelb)
            unplay(ox, r, c, 1)
            -- update outer 'best' (no 'local' here)
            best = math.max(best, evals)
            a = math.max(a, best)        -- update alpha
            if a >= b then
                break
            end
        end
        return best
    else
        local best = math.huge
        for _,inside in ipairs(allposmove(ox)) do
            local r,c = inside[1], inside[2]
            play(ox,r,c,2)
            local evals = minimax(ox, depth+1, true, a, b, ailevelb)
            unplay(ox, r, c, 2)
            best = math.min(best, evals) -- update outer 'best'
            b = math.min(b, best)        -- update beta
            if a >= b then
                break
            end
        end
        return best
    end
    
end

function bestmove(ox,turn,ailevel)
    local bestval
    local moves = {}
    if turn == 1 then
        bestval = -math.huge
    else
        bestval = math.huge
    end

    for _,inside in ipairs(allposmove(ox)) do
        local r,c = inside[1], inside[2]
        play(ox,r,c,turn)  -- play with the candidate move using 'turn'
        -- call minimax from the *next* player's perspective:
        local isNextMax = (turn == 2)  -- if we just played 'turn', next is the other
        -- But our minimax defines ismax == true means O's turn.
        -- Simpler: call minimax with ismax = (next player is O)
        local nextPlayer = (turn == 1) and 2 or 1
        local ismax_next = (nextPlayer == 1)
        local moveVal = minimax(ox, 1, ismax_next, -math.huge, math.huge, ailevel)
        unplay(ox, r, c, turn)

        if (turn == 1 and moveVal > bestval) or (turn == 2 and moveVal < bestval) then
            bestval = moveVal         -- IMPORTANT: update bestval
            moves = {{r,c}}
        elseif moveVal == bestval then
            moves[#moves+1] = {r,c}
        end
    end

    -- safety: if moves empty, return first empty
    if #moves == 0 then
        local empt = allposmove(ox)
        return empt[1][1], empt[1][2]
    end

    local pick = moves[math.random(1,#moves)]
    return pick[1], pick[2]
end

function boardEqual(a, b)
    for i = 1, #a do
        for j = 1, #a[i] do
            if a[i][j] ~= b[i][j] then
                return false
            end
        end
    end
    return true
end

function newBoard()
    local oh = {}
    for row = 1,3 do
        oh[row] = {0,0,0}
    end
    return oh
end

function getenemies(all,side)
    if side == 'O' then
        return all.Plac.SurfaceGui.Placar.X.player.Value
    else
        return all.Plac.SurfaceGui.Placar.O.player.Value
    end
end

_G.on = true
local current
while wait() do
    if not _G.on then continue end
    local side = game.Players.LocalPlayer.Character:FindFirstChildWhichIsA('Tool')
    if not side then continue end
    local position = game.Players.LocalPlayer:GetAttribute('jogo')
    if not position then continue end
    local me = game:GetService("Players").LocalPlayer.PlayerGui[position]
    local all = game:GetService("Workspace").all[position]
    if not getenemies(all,side) then continue end
    side = game.Players.LocalPlayer.Character:FindFirstChildWhichIsA('Tool').Name:sub(1,1)
    local side2 = side
    side = (side == 'O') and 1 or 2
    local ox = getboard(me)
    local currentturn = (all.Plac.SurfaceGui.Placar.Quem.Text:sub(2,2) ~= "-") and all.Plac.SurfaceGui.Placar.Quem.Text:sub(2,2) or false
    if currentturn and side2 == currentturn and (not current or not boardEqual(current, ox)) and ismoveleft(ox) and checkwin(ox) == 0  then
        showboard(ox)
        wait(0.5)
        print("Moves left:", ismoveleft(ox))
        local r,c = bestmove(ox,side,9)
        print("Best move for O:", r,c)
        local yeah = me['P'..r..c]
        print(yeah)
        local checkwow = getpos(yeah)
        presspos(checkwow)
        wait(0.5)
        current = getboard(me)
        repeat task.wait()
        until not boardEqual(current, getboard(me)) or not getenemies(all,side)
    end
    task.wait()
end
