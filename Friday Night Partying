local Keybinds = {{{Enum.KeyCode.A, Enum.KeyCode.Left, Enum.KeyCode.ButtonL2, Enum.KeyCode.ButtonX}, {Enum.KeyCode.S, Enum.KeyCode.Down, Enum.KeyCode.ButtonL1, Enum.KeyCode.ButtonA}, {Enum.KeyCode.W, Enum.KeyCode.Up, Enum.KeyCode.ButtonR1, Enum.KeyCode.ButtonY}, {Enum.KeyCode.D, Enum.KeyCode.Right, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonB}}, {{Enum.KeyCode.S, Enum.KeyCode.Z, Enum.KeyCode.One}, {Enum.KeyCode.D, Enum.KeyCode.X, Enum.KeyCode.Two}, {Enum.KeyCode.F, Enum.KeyCode.C, Enum.KeyCode.Three}, {Enum.KeyCode.J, Enum.KeyCode.B, Enum.KeyCode.Eight}, {Enum.KeyCode.K, Enum.KeyCode.N, Enum.KeyCode.Nine}, {Enum.KeyCode.L, Enum.KeyCode.M, Enum.KeyCode.Zero}}, {{Enum.KeyCode.A, Enum.KeyCode.One}, {Enum.KeyCode.S, Enum.KeyCode.Two}, {Enum.KeyCode.D, Enum.KeyCode.Three}, {Enum.KeyCode.F, Enum.KeyCode.Four}, {Enum.KeyCode.Space}, {Enum.KeyCode.H, Enum.KeyCode.Seven}, {Enum.KeyCode.J, Enum.KeyCode.Eight}, {Enum.KeyCode.K, Enum.KeyCode.Nine}, {Enum.KeyCode.L, Enum.KeyCode.Zero}}, {{Enum.KeyCode.D, Enum.KeyCode.Left}, {Enum.KeyCode.F, Enum.KeyCode.Down}, {Enum.KeyCode.Space}, {Enum.KeyCode.J, Enum.KeyCode.Up}, {Enum.KeyCode.K, Enum.KeyCode.Right}}, {{Enum.KeyCode.S, Enum.KeyCode.Z, Enum.KeyCode.One}, {Enum.KeyCode.D, Enum.KeyCode.X, Enum.KeyCode.Two}, {Enum.KeyCode.F, Enum.KeyCode.C, Enum.KeyCode.Three}, {Enum.KeyCode.Space}, {Enum.KeyCode.J, Enum.KeyCode.B, Enum.KeyCode.Eight}, {Enum.KeyCode.K, Enum.KeyCode.N, Enum.KeyCode.Nine}, {Enum.KeyCode.L, Enum.KeyCode.M, Enum.KeyCode.Zero}}, {{Enum.KeyCode.A, Enum.KeyCode.One}, {Enum.KeyCode.S, Enum.KeyCode.Two}, {Enum.KeyCode.D, Enum.KeyCode.Three}, {Enum.KeyCode.F, Enum.KeyCode.Four}, {Enum.KeyCode.J, Enum.KeyCode.Seven}, {Enum.KeyCode.K, Enum.KeyCode.Eight}, {Enum.KeyCode.L, Enum.KeyCode.Nine}, {Enum.KeyCode.Semicolon, Enum.KeyCode.Zero}}, {{Enum.KeyCode.A}, {Enum.KeyCode.S}, {Enum.KeyCode.D}, {Enum.KeyCode.F}, {Enum.KeyCode.C}, {Enum.KeyCode.V}, {Enum.KeyCode.N}, {Enum.KeyCode.M}, {Enum.KeyCode.J}, {Enum.KeyCode.K}, {Enum.KeyCode.L}, {Enum.KeyCode.Semicolon}}};
local newkeys = {}
local Marked = {}
local Hitted = {}
_G.side = 1
_G.on = true

local vim = game:GetService("VirtualInputManager")

local function pressKey(key, state)
    if key then
        vim:SendKeyEvent(state, key, false, game)
    else
        warn("Invalid key provided: ", key)
    end
end

function printkey()
    for i,v in next,newkeys do
    for a,b in next, v do
        print(i .. ' Keys','Keys ' .. a,b)
    end
    end
end

for i,v in next, Keybinds do
    -- Initialize newkeys[#v] if it doesn't exist
    if not newkeys[#v] then
        newkeys[#v] = {}
    end

    for a,b in next,v do
        for c,d in next,b do
            if c == 1 then
                newkeys[#v][a] = d
            end
        end
    end
end

local gameui = game:GetService("Players").UntitiledBa.PlayerGui.GameUI.realGameUI.Notes
local NotesContain
if _G.side == 1 then
    NotesContain = gameui.DadNotes
elseif _G.side == 2 then
    NotesContain = gameui.BFNotes
end

function GetContainer(Note)
    for i,v in next,NotesContain:GetChildren() do
        if tonumber(v.Name) ~= nil and v.ZIndex == 1 then
            local ContainerY = v.AbsolutePosition.Y + (v.AbsoluteSize.Y /2 )
            local ContainerX = v.AbsolutePosition.X + (v.AbsoluteSize.X /2 )
            local NoteX = Note.AbsolutePosition.X + (Note.AbsoluteSize.X /2 )
            local diff = math.abs(ContainerX - NoteX)
            if diff <= 10 then
                return {v,ContainerY,ContainerX}
            end
        end
    end
end


function getnearestnote(contain,containx)
    local final = 1000000000000
    local oxd = false
    for i,v in next,NotesContain:GetChildren() do
        if tonumber(v.Name) == nil and v.ZIndex == 2 and not Hitted[v] then
            local Currentx = v.AbsolutePosition.X + (v.AbsoluteSize.X /2 )
            local diffx = containx - Currentx
            if diffx <= 10 and diffx >= -10 then
                local Current = v.AbsolutePosition.Y + v.AbsoluteSize.Y / 2
                local Contains = contain
                local diff = (Contains - Current)
                if diff < final then
                    final = diff
                    oxd = true
                end
            end
        end
    end
    if oxd == true then
      return final
    else
      return 10000
    end
end


function nearestLast(contain,containx,Checked)
    local lol = 999999999999999
    local obj = nil
    for i,v in next,NotesContain:GetChildren() do
        if not Marked[v] and tonumber(v.Name) == nil and v.ZIndex == 1 and v.AnchorPoint.Y == 1 then
            local Currentx = v.AbsolutePosition.X + (v.AbsoluteSize.X /2 )
            local diffx = containx - Currentx
            if diffx <= 10 and diffx >= -10 then
                local Current = v.AbsolutePosition.Y + v.AbsoluteSize.Y
                local Contains = contain
                local diff = (Contains - Current)
                local xd = 1000
                if not Marked[v] and  diff < lol  and diff < getnearestnote(contain,containx) then
                    lol = diff
                    obj = v
                end
            end
        end
    end
    if obj then
        if Checked == true then
            Marked[obj] = true
        end
        return obj
    end
end

function keycount()
    local keycounts = 0
    for i,v in next,NotesContain:GetChildren() do
            if tonumber(v.Name) ~= nil and v.ZIndex == 1 then
                keycounts = keycounts + 1
            end
    end
    return keycounts
end


function keydone(containerIndex,note,keysss,lockedcontainerY,lockedContainerX,container1)
    if container1 and not Marked[note] then
            Marked[note] = true
            task.defer(function()
                repeat 
                task.wait(0)
                until math.abs(container1.AbsolutePosition.Y + (container1.AbsoluteSize.Y /2 ) - (note.AbsolutePosition.Y + (note.AbsoluteSize.Y/2))) <= 20
                Hitted[note] = true
                pressKey(newkeys[keysss][containerIndex], true)
                if nearestLast(lockedcontainerY,lockedContainerX,false) then
                    local xd = nearestLast(lockedcontainerY,lockedContainerX,true)
                    repeat 
                        task.wait(0)   
                    until xd == nil or xd.AbsoluteSize.Y == 0
                    pressKey(newkeys[keysss][containerIndex], false)
                else
                    pressKey(newkeys[keysss][containerIndex], false)
                end
            end)
    end
end


print('work',keycount())

local function processNotes()
    local keysss = keycount() -- Cache keycount at the start of processing

    for _, note in ipairs(NotesContain:GetChildren()) do
        if tonumber(note.Name) == nil and note.ZIndex == 2 and not Marked[note] then
            local containerData = GetContainer(note) -- Cache container data
            if containerData then
                local containerY = containerData[2]
                local ContainerX = containerData[3]
                local containerReal = containerData[1].AbsolutePosition.Y
                local container1 = containerData[1]
                local currentY = note.AbsolutePosition.Y + (note.AbsoluteSize.Y / 2)
                local diff = containerY - currentY
                local containerIndex = tonumber(containerData[1].Name)
                local lockedcontainerY = containerY
                local lockedContainerX = ContainerX
                local lockedContainer = containerReal
                keydone(containerIndex,note,keysss,lockedcontainerY,lockedContainerX,container1)
            end
        end
    end
end

-- Main loop
while _G.on == true do
    if NotesContain.Visible == true then
        task.defer(processNotes) -- Process all notes in one deferred task
    else
        table.clear(Marked)
        table.clear(Hitted)
    end
    wait()
end
